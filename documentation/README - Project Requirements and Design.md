The secure chat client Team MIDI designed and implemented successfully achieves end-to-end message confidentiality by executing message encapsulation and decapsulation on the client side before sending the messages to the network. It also achieves integrity by performing HMAC digest generation before sending encrypted messages and HMAC verification when decapsulating received messages. Finally, the system achieves user authentication by implementing login as an API request on our front end server and requiring the server generated authentication token when sending and receiving messages. Our goals were achieved by designing and implementing our solutions with these objectives in mind.

The encapsulator/decapsulator itself uses Python’s cryptography library’s Hazmat Primitives libraries to implement AES and RSA encryption/decryption and HMAC generation/verification. When an encryptor object is constructed, block size, IV size, key size, and public key information must be passed to the new object. It’s encrypt function takes a string message as an input and begins by performing AES in CBC mode encryption. The key for AES encryption is generated locally using Python’s OS library’s urandom() function. After AES encryption, the encrypted message is passed to an HMAC function that uses an OS generated key to produce an HMAC verification tag for the encrypted message. Finally, the HMAC and AES keys are encrypted using the public key that was passed to the encryptor. The encryption function’s final output is a dictionary containing the ciphered message with the IV prepended to it, the HMAC tag, and the RSA encrypted HMAC and AES keys.

The decryptor works just like the encryptor, only in reverse, using Python and the same libraries. It receives a dictionary containing the encapsulated message and begins by RSA decrypting the keys. The HMAC key is then used to verify the received encrypted message’s integrity. Finally, it uses the decrypted AES key to decrypt the ciphered message and return it as a string.
The server is an AWS instance running Node, Nginx, and MongoDB to perform the necessary functions. We wrote API routes to handle sending and receiving messages, and also registering and logging in users. When a user beings using the chat client, they must first login by sending the server a POST request using their username and password. The server then checks the user model to see if that user exists, then salts and hashes the password received using bcrypt and compares the password to the salted and hashed password it has stored in the database. Our server does not store passwords in plaintext, which is always a terrible design flaw. If login is successful, the server then issues a JWT authentication token. When a user sends a message using a POST request, the server checks the request header for an authentication token, if the token is valid then it stores the message in the chat model. When a user requests to receive messages, the server receives a GET request with the user’s authentication token in the header. If the token is valid, then the server sends back the user’s messages.

The client is also written in Python and uses Python’s built in Requests library to communicate with the server. When a user wishes to login, they pass their username and password to the client through the main application and the client sends the server a POST request. If login is successful then the client stores the user’s authentication token for further use. When a user wishes to send a message, the client receives their message as a string input and send a POST request to the server with the message in the body and the stored authentication token in the header. When a user wishes to receive their messages, the client sends a get request to the server to receive unread messages for the user with their stored authentication token in the header. If this request is successful then all unread messages are received and then marked as read through a GET request to update the message, again with the user’s stored authentication token in the header.

Included in this folder are attack tree, system component, and use case diagrams
